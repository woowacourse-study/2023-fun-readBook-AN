# 4장. 오류

## 4.1 복구 가능성
### 4.1.1 복구 가능한 오류
많은 소프트웨어 오류는 치명적이지 않고 발생해도 사용자가 알아채지 못하도록 적절하게 처리하면 작동을 계속할 수 있는 합리적인 방법이 있다.

ex) 사용자가 잘못된 전화번호를 입력했을 때 전체 시스템이 멈춘다면 훌륭한 사용자 경험이 아니다.
대신 사용자에게 전화번호가 유효하지 않다는 오류 메세지를 제공하고 올바른 번호를 입력하도록 요청하는 것이 더 낫다.

복구 가능한 오류의 예
- 네트워크 오류: 의존하는 서비스에 연결할 수 없다면 기다리거나 사용자에게 네트워크를 확인하라고 한다.
- 중요하지 않은 작업 오류: 예를 들어 서비스 사용을 로깅하는 부분에서 문제가 발생한다면 실행 계속해도 무방함.
- 잘못된 사용자 입력

시스템의 외부 무언가에 의해 야기되는 오류는 대부분 표나지 않고 적절하게 처리해야한다.
오류 처리 방법을 알고있는 더 high layer 의 코드에서 오류를 처리하는 경우가 더 많다.

### 4.1.2 복구할 수 없는 오류

오류가 발생하고 시스템이 오류를 복수할 수 있는 합리적인 방법이 없는것은 개발자의 코드가 뭔가를 망쳐놓은 것이다.
- 코드와 함께 추가되어야 할 리소스가 없다.
- 어떤 코드가 다른 코드를 잘못 사용한다.

복구할 방법이 없다면 피해를 최소화하고 문제 발견 및 해결 가능성을 최대화하라.

### 4.1.3 호출하는 쪽에서만 오류 복구 가능 여부를 알 때가 많다.

다음 중 하나에 해당한다면 함수에 제공된 값으로 발생하는 오류는 호출하는 쪽에서 복구해야한다.
- 함수가 어디서 호출될지 그리고 호출 시 제공되는 값이 어디서 올지 정확한 지식이 없다.
- 함수가 재사용될 가능성이 희박하다.

### 4.1.4 호출하는 쪽에서 복구하고자 하는 오류에 대해 인지하도록 하라

함수를 호출하는 개발자가 오류를 처리하는 코드를 작성하지 않는 상태에서 오류가 발생하는 경우 개발자의 예상과 다른 결과 초래

## 4.2 견고성 vs 실패

오류 발생 시 다음 중 하나를 선택 
1. 실패, 더 높은 계층에서 오류를 처리하거나 전체 프로그램 작동을 멈추게한다.
2. 오류를 처리하고 계속 진행

### 4.2.1 신속하게 실패하리

신속하게 실패하기는 가능한 문제의 실제 발생 지점으로 부터 가까운 곳에서 오류를 나타내는 것
복구할 수 있으면 안전하게 복구할 수 있는 기회를, 복구할 수 없으면 문제를 신속하게 파악하도록 도움을 준다.

실패의 신속한 표시는 그 함수가 잘못된 입력과 함께 호출되는 즉시 오류를 발생시키는 것
잘못된 값임에도 불구하고 계속 실행해 코드의 다른 곳에서 문제를 일으키는 상황과 반대된다.

오류가 신속하게 실패하지 않으면 오류의 실제 위치를 찾기위해서 멀리서 역방향 조사가 필요하다.
신속하게 실패하면 대개의 경우 오류의 정확한 위치가 즉시 확인된다.

### 4.2.2 요란하게 실패하라

프로그램이 복구할 수 없는 오류가 발생하면 프로그래밍 오류 or 개발자의 실수
버그가 일어났다는 사실을 알 수 있게하는 방법
1. 예외를 발생해 프로그램이 중단
2. 오류 로그를 기록해서 부지런하게 확인

신속, 요란하게 오류 발생하도록 만들면 개발 도중이나 테스트하는 동안 버그가 발생할 가능성이 크다.

### 4.2.3 복구 가능성의 범위

해당 요청내에서 처리를 복구하는 방법은 없지만 시스템 작동이 멈추거나 서버 전체적으로는 복구할 수 있다.
프로그램이 멈추도록 하는 것이 가장 요란하지만, 이는 소프트웨어를 견고하지 못하게 만든다.

이 두 목표는 양립하지 못할 때가 많다. 

해결책으로 프로그래밍 오류가 발견되면 개발자가 알아차릴 수 있도록 모니터링 하는 것이다. 기록, 디버그할 수 있게 만들기, 오류 발생이 잦으면 알림 메세지

### 4.2.4 오류를 숨기지 않음

전체 소프트웨어 동작을 멈추지 않게 하기 위해 코드의 독립적이거나 중요하지 않은 부분을 분리하면 견고한 시스템을 구축할 수 있다.
조심스럽게, 조금씩, 상당히 높은 계층의 코드에서 이루어져야 한다. 독립적이지 않거나, 중요하거나, 낮은 계층에서 오류가 발생함에도 계속 진행하면 의도한 대로 작동하지 않는 경우가 많다.

**오류를 숨기면 코드가 훨씬 더 단순해지고 번거러운 오류 처리를 피할 수 있지만 좋은 생각이 아니다.**

- 호출하는 쪽에서 복구하고자 할 수 있는 오류를 숨기면 복구할 수 있는 기회를 잃는다.
- 예측한대로 코드가 실행되지 않는데 오류를 감춘 쪽은 잘 작동한다고 생각해서 못찾는다.

오류를 숨기는 방법 
1. 기본값 반환
2. 널 객체 패턴 (오류 발생 시 널)
3. 아무것도 하지 않음
4. 예외를 잡고 무시 or 로깅

## 4.3 오류 전달 방법

높은 계층으로 오류를 알리는 방법

- 명시적 방법 : 직접 호출한 쪽에서 오류가 발생할 수 있음을 인지할 수 밖에 없도록 한다.
  - checked Exception
  - return Nullable  (null safety 할 때)
  - return Optional 
  - return Result
  - return OutCome(반환값 확인이 필수인 경우)
  - swift exception
  
- 암시적 방법 : 호출하는 쪽에 오류를 알리지만, 호출하는 쪽에서 그 오류를 신경쓰지 않아도 된다.
  - unchecked Exception
  - return magic value (피해야 한다)
  - promise or future
  - assertion
  - check(구현에 따라 다름)
  - 패닉

### 4.3.1 요약: 예외
checked Exception 

### 4.3.2 명시적 방법: checked Exception

컴파일러는 checked Exception 에 대해 호출하는 쪽에서 예외를 인지하도록 강제 조치한다. 
예외를 포착하지 않거나 함수 시그니처에 선언하지 않으면 컴파일 되지 않는다.

### 4.3.3 암시적 방법: unchecked Exception
다른 개발자들은 예외가 발생할 수 있다는 사실을 전혀 모를 수 있다. 문서화 하는 것이 바람직하다.
예외 처리 및 포착을 하지 않아도 컴파일 가능하다.

### 4.3.4 명시적 방법: 널값이 가능한 반환 유형
nullable type 으로 오류 발생시 null 반환, 널 처리하지 않고 사용하지 못하도록 강제

### 4.3.5 명시적 방법 : return Result  
null 이나 optional 값을 반환할 때 문제는 오류 정보를 전달할 수 없다. Result wrapping 값 반환해서 오류 정보도 전달

### 4.3.6 명시적 방법 : return 아웃컴
결과 값으로 오류인지 처리
ex) 성공이면 true 실패면 false, 성공, 실패시 ui 를 다르게 보여주기

-> 오류를 알리는데 무시될 수도 있고 한계가 있다.

### 4.3.7 암시적 방법: promise or future
비동기적으로 실행하는 코드를 작성할 때 promise 혹은 future 를 반환.
오류가 발생하면 promise 는 거부된다
오류가 발생하지 않으면 프로미스느 이행된다.
-> flow 랑 비슷한 것 같다.

프로미스가 거부될 수 있음을 아려면 자세히 알아야 한다. 명시적으로 반환하려면 Result 유형 프로미스 반환

### 4.3.8 암시적 방법: 매직값 반환
오류가 발생하면 -1 반환
이 방법은 예상을 벗어나는 결과를 가져올 수 있고 오류를 알리는 좋은 방법이 아니다.

## 4.4 복구할 수 없는 오류의 전달
복구할 가능성이 없는 오류가 발생하면 신속하고 요란하게 실패하는 것이 최상의 방법이다.
- unchecked exception 발생
- 프로그램이 panic 되도록 하기 (패닉 지원 언어 한정)
- 체크나 어서션 사용

이러한 경우 프로그램이 종료되는데 이때 스택 트레이스나 줄 번호를 제공해 오류를 찾을 수 있다.

## 4.5 호출하는 쪽에서 복구하기를 원할 수도 있는 오류 전달
오류를 어떻게 처리할 지는 팀이 동의한 철학이 다른 어떤 주장보다 중요하다.

### 4.5.1 비검사 예외를 사용해야 한다.
코드 구조를 개선할 수 있다. 오류 처리가 상위 계층에서 이루어질 수 있기 때문에 비검사 예외를 발생시키면 코드 구조를 개선할 수 있다. 
최상위 계층에서 오류를 처리하면 오류 처리 로직이 코드 전체에 퍼지지 않고 별도로 몇 개의 계층에만 있다.

개발자들이 너무 많은 명시적 오류 전달을 접하면 무시하거나 할 수 있다고 주장한다.
다른 계층까지 번지는 것을 막기 위해 오류를 숨기려고 하는 것이다.
비검사 예외를 사용에 찬성하지만 실용적으로 접근해야 한다.

### 4.5.2 명시적 기법을 사용해야 한다는 주장
비검사 예외를 사용한다면 모든 오류를 매끄럽게 처리할 수 있는 계층을 갖기가 어렵다. 호출하는 쪽에서 오류가 일어날 수도 있다고 명시적으로 알고 있다면 더 매끄럽게 처리할 수 있을 것이다. 

### 4.5.3 필자의 의견: 명시적 방식을 사용하라 
복구하기를 원하는 오류에 대해 비검사 예외를 사용하지 않는 것이 최상이다는 것이 필자의 의견이다.
비검사 예외가 완전히 문서화되는 경우가 드물며 오류가 발생할 수 있다는 것과 어떻게 처리해야하는지 개발자가 확실히 알기란 불가능에 가깝다.
호출하는 쪽에서 복구하기를 원할 가능성이 있다면 명시적 오류 전달 방식을 사용하는 것을 개인적으로 선호한다.

## 4.6 컴파일러의 경고를 무시하지 말라
컴파일러는 오류 뿐만 아니라 경고도 알려준다. 이에 주의를 기울이면 코드베이스에 병합되기 훨씬 전에 오류를 발견하고 제거할 수 있다. 