# 04. 오류

## 복구 가능성

### 복구 가능한 오류

- 오류가 치명적이지 않고, 발생하더라도 사용자가 알아채지 못하도록 처리하여 작동을 계속할 수 있도록 하는 방법
    - e.g. 전화번호를 잘못 입력했을 때, 작동을 멈추는 대신, 잘못 입력했다는 오류 메시지를 제공한다.
- **잘못된 사용자 입력**, **네트워크 오류**, **중요하지 않는 작업 오류** 등
    - 네트워크 오류 → 몇 초 기다려주거나, 사용자에게 네트워크 연결을 확인하도록 요청
- 시스템 외부의 무언가에 의해 야기되는 오류는, 발생 가능성이 매우 예상되는 오류이므로, 적절하게 처리하기 위한 노력이 필요하다.

### 복구할 수 없는 오류

- 오류가 발생하고 시스템이 오류를 복구할 수 있는 합리적인 방법이 없을 때가 많다.
- **프로그래밍 오류**인 경우가 대다수
    - e.g. 리소스 부재, 잘못된 입력 인수 호출, 사전 초기화가 안된 경우 등
- 피해를 최소화하고, 개발자가 문제를 발견하고 해결할 가능성을 최대화하는 방법

### 오류 복구 가능 여부

- 대부분의 오류는, 한 코드가 다른 코드를 호출할 때 발생한다.
    - 함수가 어디서 호출될지, 호출 시 제공되는 값이 어디서 오는지 정확히 모를 때,
    - 코드가 미래에 재사용될 가능성이 아주 희박할 때,
    - 함수에 제공되는 값에 인한 오류는 호출하는 쪽에서 복구해야 한다.
- 다른 코드가 자신의 코드를 호출할 때, 오류가 발생하는 것을 사전에 알기 어렵다.
    - 함수의 작성자는 함수 오류 발생 가능성을 호출하는 쪽에서 인지할 수 있도록 해야 한다.

## 견고성 vs 실패

- 오류를 발생했을 때 시나리오
    1. 실패: 더 높은 코드 계층이 오류를 처리하게 하거나, 전체 프로그램의 작동을 멈춘다.
    2. 오류를 처리하고 계속 진행한다.

### 신속한 실패 (failing fast)

- 가능한 한 문제의 실제 발생 지점으로붙터 가까운 곳에서 오류를 나타낸다.
- 복구할 수 있는 경우 → 오류를 안전하게 복구할 수 있는 기회를 최대한으로 제공
    
    복구할 수 없는 경우 → 문제를 신속하게 파악하고 해결할 수 있는 기회를 최대한으로 제공
    
    ⇒ 소프트웨어가 의도치 않게 잠재적으로 위험한 상태가 되는 것을 방지
    
- e.g. 잘못된 인수로 함수를 호출하는 경우, 신속한 실패 표시
- 신속하지 않게 실패한다면
    - 문제가 발생할 때 디버그 어려움
    - 코드가 제대로 작동하지 않거나, 잠재적 문제 보유 가능성

### 요란한 실패 (failing loudly)

- 버그가 있다는 사실을 알지 못하면 고칠 수 있는 방법도 없다.
- 오류가 발생함에도 불구하고, 아무도 모르는 상황을 막기 위함이다.
- 가장 명백한 방법: 예외를 발생시켜 프로그램을 중단하는 것
    
    다른 방법: 오류 메시지를 기록하는 것 → 개발자의 부지런함 정도에 따라, 다른 메시지가 얼마나 있는지에 따라 무시될 가능성 존재
    
- 신속하고 요란한 오류는 개발 혹은 테스트 도중 오류가 발견될 가능성이 커진다!

### 복구 가능성의 범위

- 요청을 처리하는 범위 내에서 복구하는 합리적인 방법은 없지만, 시스템 전체가 작동을 멈추는 것은 방지할 수 있다. → 해당 요청 범위 내에서는 복구할 수 없지만, 서버 전체적으로는 복구할 수 있다.
- 한 번의 잘못된 요청으로 서버 동작이 멈추지 않도록 **견고하게 소프트웨어를 작성하는 것**이 좋다.
    
    그러나 오류를 알아차릴 수 있도록 하기 위해 코드는 **요란하게 실패**해야 한다.
    
    ⇒ 가장 요란한 실패는 시스템이 멈추는 것 아닌가요??
    
- 해결책: **프로그래밍 오류가 발견되면, 개발자가 이를 알아차릴 수 있도록 오류를 기록하고 모니터링을 하는 것**
    - 상세 오류 정보를 기록하여 개발자가 디버그 할 수 있도록 하고, 오류 발생률이 높아지면 개발자에게 알림 메시지를 보낸다.

### 오류를 숨기지 않음

- 호출하는 쪽에서 오류를 숨기면 → 호출하는 쪽에서 오류를 복구할 기회를 없애는 것
- 복구할 수 없는 오류를 숨기면 → 프로그래밍 오류가 감춰진다. 즉, 개발자들은 이 오류를 알 수 없다.
- 오류를 숨기면 → 에러가 발생했을 때, 호출하는 쪽에서 예측한 대로 코드가 실행되지 않음을 의미한다.
- 오류 발생 사실을 숨기는 방법
    - 기본값 반환
        - 오류가 발생하여 원하는 값을 반환할 수 없는 경우, 기본값을 반환하는 방법
        - 유용한 경우도 있지만, 오류 처리에 있어서는 적합하지 않다.
    - 널 객체 패턴
        - 기본값과 유사함. 실제 반환값처럼 보이지만, 사실 아무것도 하지 않거나 의미 없는 기본값을 반환하는 방법
        - 역시나, 유용한 경우도 있지만, 오류 처리에 있어서는 적합하지 않다.
    - 아무 것도 하지 않음
        - 오류가 발생했다는 신호를 보내지 않는 방법
        - 호출하는 쪽에서는 코드에서 작업이 의도대로 완료되었다고 생각하므로 바람직하지 않은 방법이다.

## 오류 전달 방법

- 오류로부터 복구할 수 없는 경우 → 더 높은 계층으로 오류를 알려, 높은 계층에서 실행을 중지하고 오류를 기록한다.
    
    오류로부터 복구가 가능한 경우 → 즉시 호출하는 쪽에 오류를 알려 정상적으로 처리할 수 있도록 한다.
    

### 오류를 알리는 방법

- **명시적 방법** - 요란한 실패
    - 코드를 직접 호출한 쪽에서 오류가 발생할 수 있음을 인지할 수밖에 없도록 한다.
    - e.g. 검사 예외, 널 반환 유형, 옵셔널 반환 유형, 리절트 반환 유형, 스위프트 오류 등
- **암시적 방법** - 조용한 실패
    - 코드를 호출하는 쪽에 오류를 알리고, 호출하는 쪽에서는 오류를 신경쓰지 않아도 된다.
    - 오류가 발생할 수 있음을 알기 위해서는 적극적인 노력(문서, 코드를 읽는 등)이 필요하다.
    - e.g. 비검사 예외, 어설션, 체크, 프로미스/퓨처 등

### 검사 예외  `명시적`

- 오류 전달
    
    ```java
    Double function(Double value) **throws ~~~Exception** { // 예외 발생 가능성 명시
        if (condition) **throw new ~~~Exception(value)**    // 오류가 있을 때 예외 발생
        return ~
    }
    ```
    
- 예외 처리
    
    ```java
    void main() {
        **try** {
            function()
        } **catch (~~~Exception e) {
            // error
        }**
    }
    ```
    

### 비검사 예외  `암시적`

- 오류 전달
    
    ```java
    /**
    * @throws ~~~Exception ~~~~ // 문서화 (권장사항)
    */
    Double function(Double value) { 
        if (condition) **throw new ~~~Exception(value)**    // 오류가 있을 때 예외 발생
        return ~
    }
    ```
    
- 예외 처리
    
    ```java
    void main() {
        **try** {
            function()
        } **catch (~~~Exception e) {
            // error
        }**
    }
    ```
    

### 널값이 가능한 반환 유형  `명시적`

- 오류 전달
    
    ```java
    Double**?** function(Double value) { 
        if (condition) **return null**  // 오류가 있을 때 null 반환
        return ~
    }
    ```
    
- 예외 처리
    
    ```java
    void main() {
        **if (function(value) == null) {
            // error
        }** else {
        }
    }
    ```
    

### 리절트 (result) 반환 유형 `명시적`

- 호출자에게 값을 얻을 수 없음 + 얻을 수 없는 이유를 함께 알려주기 위함
- Result 유형 (지원하는 언어: swift, Rust 등)
    
    ```java
    class Result**<V, E>** { // generic -> 어떤 유형의 값/오류에 대해 사용 가능
        static Result<V, E> ofValue(V value)
        static Result<V, E> ofError(E error)
        Boolean hasError()
        V getValue()
        E getError()
    }
    ```
    
- 오류 전달
    
    ```java
    class ~~~Error extends Error
    
    Result<Double, ~~~Error> function(Double value) { 
        if (condition) **return Result.ofERROR(~~)**    // 오류가 있을 때 오류 리절트 반환
        **return Result.ofValue(~~)**  // 함수의 결괏값
    }
    ```
    
- 예외 처리
    
    ```java
    void main() {
        Result<Double, ~~~Error> result = function(value)
        **if (result.hasError()) {
            // error
        }** else { }
    }
    ```
    

### 아웃컴 반환 유형 `명시적`

- 무언가를 수행할 뿐, 값을 반환하지 않는 함수
    - 함수가 수행한 동작의 결과를 나타내는 값을 반환하도록 함수를 수정
    - 반환값이 무시될 가능성이 있다. ⇒ 애너테이션 활용
- 오류 전달
    
    ```java
    **@CheckReturnValue**  // 함수의 반환값을 무시하면 안 됨을 표시
    Boolean send(Channel channel, String message) {
        if (channel.isOpen()) {
            channel.send(message)
            **return true**
        }
        **return false**
    }
    ```
    
- 예외 처리
    
    ```java
    void main() {
        **if (send(channel, "Hi"))** {
            // success
        } **else {
            // fail
        }**
    }
    ```
    

### 프로미스 (promise) , 퓨처 (future)  `암시적`

- 오류 전달
    
    ```java
    Promise function(Double value) async { // 비동기 함수
        await Timer.wait(Duration.ofSeconds(1)) // 실제 실행 전 1초 기다림
        if (condition) **throw new ~~~Exception(value)**    // 함수 내에서 예외 발생
        return ~
    }
    ```
    
- 예외 처리
    
    ```java
    void main() {
        function(value)
            **.then**(it ->
                // success
            )
            **.catch(error ->**  
                // 오류 발생 내용을 몰라 catch로 콜백을 제공하지 않으면 오류는 포착되지 않을 수 있다.
                **// error
            )**
    }
    ```
    
- 프로미스를 명시적으로 만들기 위해서는?
    - `Promise<Result<Double, ~~~Error>>` 타입을 반환..

### 매직값 반환 `암시적`

- 매직값: 함수의 반환 유형에는 적합하나 특별한 의미를 부여하는 값
- 오류 전달
    
    ```java
    Double function(Double value) { 
        if (condition) **return -1.0** // 오류가 있으면 -1을 반환
        return ~
    }
    ```
    

## 복구할 수 없는 오류의 전달

- 복구 가능성이 없는 오류 → 신속하게 실패 / 요란하게 실패
- 신속하고 요란한 실패를 위한 방법
    - 비검사 예외를 발생
    - 프로그램이 패닉이 되도록 함 (패닉을 지원하는 언어에 한해서)
    - 체크, 어서션 사용
- 프로그램이 종료되고, 오류 메시지를 통해 stack trace, 줄 번호 제공하여 오류 발생 위치를 알려준다.

## 호출하는 쪽에서 복구를 원할 수도 있는 오류의 전달

- 여전히 일치된 의견이 없는 주제입니당. 팀의 규칙을  따르는 것이 중요

### 비검사 예외를 사용해야 한다는 주장

- 코드 구조 개선
    - 오류를 처리하는 로직이 코드 전체가 아닌, 별도의 몇 개의 계층에만 존재함
- 실용성
    - 개발자들이 무엇을 할 것인지에 대해 실용적이어야 한다.
    - 너무 많은 명시적 오류 전달 → 개발자들의 실수가 많아질 것이라는 주장

### 명시적 기법을 사용해야 한다는 주장

- 매끄러운 오류 처리
    - 호출하는 쪽에 잠재적 오류를 강제적으로 인식하도록 하여, 해당 필드 바로 옆에 오류 메시지를 보여주는 것이 타당하다.
- 실수로 오류를 무시할 수 없다.
- 실용성
    - 개발자들이 무엇을 할 것인지에 대해 실용적이어야 한다.
    - 비검사 예외 → 제대로 문서화가 된다는 보장이 없음 → 실수가 많아질 것이라는 주장

## 컴파일러 경고를 무시하지 말자

- 컴파일러 오류 뿐만 아니라 컴파일러 경고 메시지도 출력된다.
    - 버그에 대한 조기 경고일 수 있다.
    