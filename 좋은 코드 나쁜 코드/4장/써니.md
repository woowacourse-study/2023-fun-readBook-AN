# 4장 오류

## 4.1 복구 가능한 오류
복구 가능한 오류에는 잘못된 사용자 입력, 네트워크 오류, 중요하지 않은 작업 오류가 있다.
네트워크 오류는 자신의 코드가 의존하는 서비스에 연결할 수 없는 경우 몇 초 동안 기다렸다가 다시 시도하거나, 그 코드가 사용자의 장치에서 실행되는 경우라면 사용자에게 네트워크 연결을 확인하도록 요청하는 것이 최상이다.
중요하지 않은 작업 오류는 서비스 사용에 대한 어떤 통계를 기록하는 부분에서 오류가 발생한다면 실행을 계속해도 무방할 것이다.

**복구할 수 없는 오류**
오류를 복구할 수 있는 방법이 없다면 유일하게 코드가 할 수 있는 합리적인 방법은 피해를 최소화하고 문제 해결을 최대화 하는 것이다.
예로, **신속한 실패**와 **요란한 실패**라는 개념이 있다.

**호출하는 쪽에서만 오류 복구 가능 여부를 알 때가 많다**
> 아마 내가 작성하는 코드 대부분이 이러한 문제를 안고 있는 것 같다.

**호출하는 쪽에서 복구하고자 하는 오류에 대해 인지하도록 하라**

## 4.2 견고성 vs 실패
오류가 발생할 떄, 다음 중 하나를 택해야 한다.
+ 실패, 더 높은 코드 계층이 오류를 처리하게 하거나 전체 프로그램의 작동을 멈추게 한다.
+ 오류를 처리하고 계속 진행한다.

> 여태 작성한 내 코드들을 살펴봤을 때, 나는 위 두가지를 골고루 사용하는 것 같다.(물론 적절하게 사용했다고는 장담 못함)
> 존재하지 않는 상태일 때는 throw 해서 프로그램 작동을 멈추게 하거나
> 도메인 로직에서의 require()와 같은 예외 발생 로직을 App 단에서 runCatching을 통해 오류를 처리한다던가 등..

**신속하게 실패하라**
지난 레벨1에서 몇 번 피드백 받았던 내용이다. 코드를 빠르게 실패하지 않는 경우 실제 발생한 오류 지점보다 멀리 떨어진 곳에서 오류가 발생해 오류를 찾아내기 힘들어 질 수 있다.
이런 문제를 해결하기 위한 방법 중 하나가 신속하게 실패하는 것이다.

**요란하게 실패하라**
오류가 발생하는데도 불구하고 아무도 모르는 상황을 막고자 하는 것이다. 예로, 예외를 발생해 프로그램이 중단되게 하는 것이다.
> 내가 기존에 존재하지 않는 상태일 때 throw 해서 프로그램의 작동을 멈추게 하는 것이 이에 해당한다.


### 4.2.4 오류를 숨기지 않음
오류를 숨기는 행위는 코드가 단순해지고 번거로운 오류처리를 피할 순 있지만, 좋은 생각은 아니다. 오류를 숨기는 행위는 복구할 수 있는 오류와 복구할 수 없는 오류 모두에 문제를 일으킨다.

**기본값 반환**
내가 제일 싫어하는 방식이다. 오류가 발생하고 원하는 값을 반환할 수 없는 경우 기본 값을 반환하는 방식인데, 이러한 방식은 사용자에게 혼동을 야기한다.
> Android LiveData에 기본값을 지정해줘야하는 경우가 있는데 이또한 너무 싫다.

**널 객체 패턴**
개념적으로는 기본값과 유사하지만 더 확장해 복잡한 객체(클래스 등)을 다룬다. 널 객체는 실제 반환값처럼 보이지만 모든 멤버 함수는 아무것도 하지 않거나 의미 없는 기본값을 반환한다.
이러한 널 객체 패턴은 양날의 검이다. 유용할 수 있지만, 오류 처리에 사용하는 것은 바람직 하지 않다.

**아무것도 하지 않음**
코드가 무언가를 반환하지 않고 단지 어떤 작업을 수행하는 경우, 문제가 발생할 때 가능한 한가지 옵션은 오류가 발생했다는 신호를 보내지 않는 것이다.
이럴 경우 이후 호출되는 함수, 로직에서는 앞선 내용이 정상적으로 수행되었다고 생각하고 실행되기 때문에 실제 수행과 불일치를 일으킬 가능성이 높다.

## 4.3 오류 전달 방법
**명시적 방법**
> 코드를 직접 호출한 쪽에서 오류가 발생할 수 있음을 인지할 수밖에 없도록 한다.
**암시적 방법**
> 코드를 호출하는 쪽에 오류를 알리지만 호출하는 쪽에서 그 오류를 신경쓰지 않아도 된다.

|  | 명시적 오류 전달 기법 | 암시적 오류 전달 기법 |
|:---|:---:|:---:|
| 코드 계약에서의 위치 | 명확한 부분 | 세부 조항 혹은 아예 없음 |
| 호출하는 쪽에서 오류 발생 가능성에 대해 아는가? | 예 | 알 수도 있고, 모를 수도 있다. |
| 기법의 예 | 검사 예외<br>널 반환 유형(널 안정성의 경우)<br>옵셔널 반환 유형<br>리절트 반환 유형<br>아웃컴 반환 유형(반환값 확인이 필수인 경우)<br>스위프트 오류 | 비검사 예외<br>매직값 반환(피해야 함)<br>프로미스 또는 퓨처<br>어서션<br>체크(구현에 따라 달라짐)<br>패닉 |

### 4.3.1 요약: 예외
**명시적 방법**
**검사 예외**
오류를 전달하기 위한 명시적인 방법으로 호출하는 쪽에서 예외를 인지하도록 강제적으로 조치한다. (컴파일 에러)
> 함수 시그니처에 예외를 발생시킬 수 있다고 표시해야 한다고 한다. 근데 코틀린은 이를 지원하나..? 찾아보니 use 함수를 사용해 자원 관리를 하라는데 따로 알아보자.

**널값이 가능한 반환 유형**
함수에서 널값을 반환하는 것은 특정값을 계산하거나 얻는 것이 불가능함을 나타내기 위한 효과적이고 간단한 방법이다.
> UI 단에서 주로 내가 사용하는 예외 처리 방법이다. 명시적으로 Null 처리를 요구하고, 널값을 처리하지 않았을 경우 적절한 처리(메시지 표시 등)를 수행한다.

**리절트 반환 유형**
호출자에게 값을 얻을 수 없음을 알릴 뿐 아니라 값을 얻을 수 없는 이유까지 제공한다.
> 이 방법 나중에 도전해봐야징

**아웃컴 반환 유형**

**암시적 방법**
**비검사 예외**
비검사 예외는 오류가 발생할 수 있다는 것을 호출하는 쪽에서 인지하리라는 보장이 없기 때문에 오류를 암시적으로 알리는 방법이다. (런타임 에러)
> 예외가 발생했을 경우 그 예외 처리를 하지 않는 한 최상단까지 간다.

**프로미스 또는 퓨처**

**매직값 반환**
> 이렇다 할 예외 처리 방법이 뚜렷하지 않을 때 주로 사용했다. 근데 기본값 제공과 마찬가지로 이는 좋은 방식이 아니라 생각한다. 그래서 잘 사용하지 않는다.



