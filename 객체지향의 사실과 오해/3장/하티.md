# 03. 타입과 추상화

## 추상화

- 현실에서 출발하되 불필요한 부분을 도려내가면서 사물의 본질을 드러나게 하는 과정
- 불필요한 부분을 무시함으로써 현실에 존재하는 복잡성을 극복
- 추상화의 수준, 이익, 가치는 목적에 의존적이다.

> 현상은 복잡하다. 법칙은 단순하다. 버릴 게 무엇인지 알아내라.
> 

### 추상화의 두 가지 차원

- 일반화
- 단순화

## 객체

- 명확한 경계를 가지고 서로 구별할 수 있는 구체적인 사람이나 사물

## 개념

- 공통점을 기반으로 객체들을 묶기 위한 그릇
- 다양한 사물이나 객체에 적용할 수 있는 아이디어나 관념

### 개념의 3가지 관점

- **심볼**: 개념을 가리키는 간략한 이름(명칭)
- **내연**: 개념의 완전한 정의 → 객체가 개념에 속하는지 확인 가능
- **외연**: 개념에 속하는 모든 객체의 집합

## 인스턴스

- 개념이 객체에 적용됐을 때, 객체를 개념의 인스턴스 라고 한다.

## 분류

- 추상화를 위한 도구 !!
- 특정한 객체를 특정한 개념의 객체 집합에 포함시키거나 포함시키지 않는 작업
- 적절하게 분류하여야 유지보수가 용이해지며, 개발자가 객체를 쉽게 찾고 조작할 수 있게 된다.

## 타입

- 다양한 사물이나 객체에 적용할 수 있는 아이디어나 관념
- 즉, 개념과 동일함
- **데이터 타입**: 메모리 안에 저장된 데이터의 종류를 분류하는 데 사용하는 메모리 집합에 관한 메타데이터
- 데이터 타입에서 중요한 점
    - 데이터가 어떻게 사용되느냐
        - 데이터가 어떤 타입에 속하는 지를 결정하는 것 → 데이터에 적용할 수 있는 작업
            - 데이터가 숫자형이라면 더하고 뺄 수 있다
        - **연산자**: 데이터를 이용해 수행할 수 있는 작업
    - 타입에 속한 데이터를 어떻게 메모리에 표현하는지는 외부로부터 철저하게 감춰진다.
        - 산술 연산자를 알고 있다면, 메모리에 숫자가 어덯게 저장되는 지는 몰라도 된다.

## 객체와 타입

- 객체를 타입에 따라 분류하고 그 타입에 이름을 붙이는 것 → 새로운 데이터 타입을 선언하는 것
- 객체의 타입에서 중요한 점
    - 어떤 객체가 어떤 타입에 속하는 지를 결정하는 것 → 객체가 수행하는 행동
        - 동일한 행동을 수행할 수 있다면 그 객체들은 동일한 타입으로 분류될 수 있다.
    - 객체의 내부적인 표현은 외부로부터 철저하게 감춰진다.

위의 중요한 점으로부터 나오는 객체지향 설계의 중요한 원칙

## 행동이 우선이다.

- 객체를 타입으로 분류할 때 사용해야 하는 기준은 명확하다.

⇒ 같은 타입에 속한 다른 객체와 동일한 행동을 하는가

- 객체가 갖고 있는 데이터는 관심사가 아니다. **오직 행동뿐**
- 동일한 행동을 한다면, 다른 데이터를 가질 수 있다.
    - 동일한 행동 = 동일한 책임 = 동일한 메시지 수신
- **다형성**: 동일한 요청에 서로 다른 방식으로 응답할 수 있는 능력
- 그러므로 다형적인 객체들은 동일한 타입에 속한다.

### 캡슐화

- 외부에 행동만을 제공하고 데이터는 행동 뒤로 감춰야 한다.

### 책임—주도 설계

- 행동에 따라 객체 분류를 위해 데이터보다 행동을 먼저 생각해야 한다.
- 객체가 외부에 제공해야 하는 책임을 결정 → 그 책임을 수행하는 데 적합한 데이터 결정 → 책임을 수행하는 데 필요한 외부 인터페이스 뒤로 캡슐화
- 데이터—주도 설계 방법의 단점을 개선하기 위해 고안됨

## 일반화와 특수화

- 특수하다: 일반적인 개념보다 범위가 더 좁다.
- 특수한 개념은 일반적 개념의 부분 집합이 될 수 있다.
- 일반화와 특수화를 결정하는 것 역시 상태가 아닌 **행동**이다.

### 일반적 타입

- 특수한 타입이 가진 모든 행동들 중의 일부 행동만 가지는 타입
- 특수한 타입보다 더 적은 수의 행동

### 특수한 타입

- 일반적인 타입이 가진 모든 행동을 포함 + 자신만의 행동을 추가하는 타입
- 일반적 타입보다 더 많은 수의 행동
- 일반적 타입의 모든 행동을 동일하게 수행할 수 있어야 한다.

## 슈퍼타입과 서브타입

**슈퍼타입 (Supertype)**: 일반적인 타입

**서브타입 (Subtype)**: 좀 더 특수한 타입

- 역시나 두 타입의 관계는 **행동**에 의해 결정된다.
- 서브타입은 슈퍼타입을 대체할 수 있어야 한다.

## 타입과 추상화

- 앨리스 객체의 상태는 계속 변한다
    - 키가 80cm ~ 3m 까지도 계속 변한다

⇒ 앨리스 객체는 변경되는 키라는 상태를 가진다. 고 단순화한다면?

- 타입은 시간에 따라 동적으로 변하는 상태를, 시간과 무관한 **정적인 모습**으로 다룰 수 있게 한다.
- 타입은 추상화다
    - 불필요한 시간, 상태 변화라는 요소를 제거하고, 저적인 관점에서 묘사한다
    - 객체의 동적인 특성을 추상화하여,
        
        시간에 따른 객체의 시간 변경이라는 복잡성을 단순화할 수 있다.
        

## 동적 모델과 정적 모델

- 객체의 **스냅샷**: 객체가 특정 시점에 구체적으로 어떤 상태를 갖는가
- **동적 모델**: 객체가 살아 움직이는 동안 상태가 어떻게 변하고 어떻게 행동하는지를 포착하는 것
- **정적 모델 (타입 모델)**: 객체가 가질 수 있는 모든 상태와 행동을 시간에 독립적으로 표현하는 것
- 객체지향 설계 및 구현을 위해서는 <객체 관점의 동적 모델>과 <객체를 추상화한 타입 관점의 정적 모델>을 적절히 혼용해야 한다.
- 클래스를 작성하는 시점 → 정적인 관점
- 실제 애플리케이션을 실행하여 상태 변경을 추적하고 디버깅 → 동적인 관점

## 클래스

- 정적인 모델은 클래스를 이용해 구현된다.
    
    따라서 타입을 구현하는 가장 보편적인 방법은 클래스를 이용하는 것이다.
    
- 타입은 객체를 분류하기 위해 사용하는 개념,
    
    클래스는 타입을 구현할 수 있는 구현 메커니즘 중 하나이다.

---

이번 내용은 사실 조금 어렵게 느껴졌다.
특히, 타입이라는 개념이 아주 잘 이해되지는 않는 것 같다.
타입에 대해서 어떻게 앞으로 적용해보아야 할지는 아직 잘 느껴지지 않았다..
다만, 3장을 읽고 확실하게 느낀 점은, 역시나 객체지향에서는 **행동**이 중요하다는 것...!!!!
