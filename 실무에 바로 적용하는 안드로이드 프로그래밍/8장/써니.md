# UI 프래그먼트와 프래그먼트 매니저

## UI 유연성
사용자나 장치가 요구하는 것에 따라 런타임 시에 액티비티의 뷰를 구성하거나 변경할 수 있는 능력
> 세로 화면이든 가로 화면이든 다양한 화면 너비에 이상적인 UI를 제공해야 한다. (단순히 화면 전환만 되는 것이 아닌 각 화면에 맞게 더 효율적으로 보여주는 것)


## 프래그먼트?
프래그먼트는 다양한 크기의 화면을 가진 단말기가 늘어나며 이러한 크고 작은 화면의 복잡한 레이아웃 구성을 독립적인 생명주기를 가진 액티비티만으로 구성하기엔 불편함이 발생했고, 이를 해결하고자 나오게 되었다.
프래그먼트는 액티비티의 작업* 수행을 대행할 수 있는 컨트롤러 객체이다.
> 작업*: UI 관리. 이때, UI는 화면 전체 또는 일부분일 수 있다.

UI를 관리하는 프래그먼트를 **UI프래그먼트**라고 한다.
UI 프래그먼트는 레이아웃 파일로부터 인플레이트(inflate) 되는 자신의 뷰를 하나 갖는다. 이때, 프래그먼트의 뷰는 사용자가 보면서 상호 작용하기를 원하는 UI 요소들을 포함한다.

그럼 액티비티는 무엇을 할까?
- 액티비티의 뷰는 자신의 UI를 갖는 대신 프래그먼트를 넣을 컨테이너를 가지며, 이 컨테이너에는 인플레이트 된 프래그먼트의 뷰가 추가된다.

앱과 사용자가 원하는 화면을 구성하거나 변경하려면 액티비티와 연관된 하나 이상의 프래그먼트를 사용한다. 기술적으로 액티비티의 뷰는 생애(Lifecycle)동안 함께 존재하기 때문에 안드로이드의 기본 원칙에도 위배되지 않는다.


## UI 프래그먼트의 이점
- 앱의 UI를 조립 가능한 요소로 분리할 수 있어서 유용하다.
- 탭 인터페이스를 비롯한 여러 가지를 쉽게 만들 수 있다. (쉽게? 사실 프래그먼트는 쉽지 않다.)
- JetPack API 중 프래그먼트를 활용하는 API가 존재(네비게이션 컨트롤러)하는데 프래그먼트를 사용하면 API를 같이 사용할 떄도 유용하다.


## 프래그먼트와 액티비티
**호스팅**
Activity는 자신의 뷰 계층 구조에 Fragment와 그 뷰를 포함하는 곳을 제공하게 된다.
이것을 **호스팅**이라 하며, Fragment는 화면에 보이는 뷰를 자체적으로 가질 수 없고, 액티비티의 뷰 계층에 추가될 때만 화면에 자신의 뷰가 보인다.
이 때, supportFragmentManager를 통해 Fragment를 Activity의 특정 View Container에 보여줄 수 있다.


**UUID**
(Universally Unique Identifier로, 128bit의 고유한 값이다)안드로이드 프레임워크에 포함된 유틸리티 클래스
이 클래스는 고유한 ID 값을 쉽게생성하는 방법을 제공한다.


## UI 프래그먼트 생성
1. 레이아웃 파일에 위젯들을 정의해 UI를 구성한다.
2. 클래스를 생성하고 정의된 레이아웃을 이 클래스의 뷰로 설정한다.
3. 레이아웃으로부터 인플레이트된 위젯들을 코드에 연결한다.


## 다른 타입의 프래그먼트
현재는 Jetpack(androidx) 버전의 프래그먼트 사용을 권장한다.
이유는 안드로이드 프레임워크의 프래그먼트와 v4지원 라이브러리 프래그먼트의 경우 레거시 버전의 Fragment 클래스이기 때문이다.
이러한 레거시 버전의 Fragment는 Android 9.0(API 28)부터 더 이상 사용되지 않고(deprecated) 업데이트도 이루어지지 않으므로 사용을 지양해야 한다. 
> v4 프래그먼트의 경우 Jetpack 라이브러리로 옮겨져 더 이상 업데이트 되지 않는다.


## 프래그먼트의 생명주기 콜백 함수
+ Fragment의 생명주기 콜백 함수들을 살펴보면 모두 public 함수인 것을 알 수 있다. 이는 Fragment가 호스팅하는 액티비티에서도 자동 호출되기 때문이다.
+ Fragment는 액티비티와 유사하게 자신의 상태 데이터를 저장하거나 가져오는 Bundle 객체를 갖는다. 
    > Acitivty와 마찬가지로 Fragment 또한 onSaveInstanceState(Bundle)이 존재하며 이 함수를 필요에 따라 오버라이드 할 수 있다.
+ Fragment의 onCreate 콜백함수에서는 액티비티와는 다르게 프래그먼트의 뷰를 인플레이트 하지 않는다. (onCreate에서는 프래그먼트 인스턴스 구성만 함)
+ 프래그먼트의 뷰는 onCreateView에서 생성하고 구성한다.
    > 이러한 onCreateView에서는 레이아웃을 인플레이트하기 위한 LayoutInflater와 ViewGroup을 매개변수로 받고, 저장된 상태 데이터를 갖는 Bundle을 매개변수로 갖는다.

```kotlin
class TestFragemnt : Fragment() {
    ...

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup,
        savedInstanceState: Bundle?
    ): View {
        // TestFragemnt의 레이아웃을 명시적으로 인플레이트 해 view를 반환한다.
        // 이때 세 번째 인자는 attachParent 속성으로 인플레이트 된 뷰를 이 뷰의 부모(지금은 액티비티)에 즉시 추가할 것인지 알려준다.
        // Fragment에서는 대게 false로 속성을 준다. 이유는 프래그먼트는 액티비티의 컨테이너 뷰에 호스팅 되기 때문이다.
        // 따라서 이 프래그먼트의 뷰는 인플레이트 되는 즉시 부모 뷰에 추가될 필요 없고, 때에 따라 액티비티에서 필요로 할 때 이 뷰를 추가한다.
        return inflater.inflate(R.layout.fragement_test, container, false)  
    }
}
```

## UI 프래그먼트의 호스팅
UI 프래그먼트를 호스팅하기 위해 액티비티는 아래 두 가지를 수행해야 한다.
1. 액티비티의 레이아웃에 프래그먼트의 뷰를 배치할 곳을 정의해야 한다. // 프래그먼트는 레이아웃의 Fragment, FrameLayout, FragmentContainer 등과 같은 컨테이너에 올라간다.
2. 프래그먼트 인스턴스의 생명주기를 관리해야 한다.

프래그먼트를 언제 액티비티에 추가할 것인지, 이후에는 어떻게 할 것인지는 개발자의 역량이다.
뿐만 아니라, 프래그먼트를 제거하고 다른 프래그먼트로 교체할 수 있고, 다시 첫번째 프래그먼트를 추가할 수도 있다.


## FragmentManager에 UI프래그먼트 추가
FragmentManager는 프래그먼트 리스트와 프래그먼트 트랜잭션의 백 스택(back stack)을 처리한다.
FragmentManager는 프래그먼트의 뷰를 액티비티의 뷰계층에 추가하고, 프래그먼트 생명주기를 주도하는 책임을 갖는다.
FragmentManager는 v4 라이브러리에서부터 현재의 Jetpack까지 supportFragmentManager로 불리는 FragmentManager를 통해 관리한다.


## Fragment Transaction
프래그먼트로 런타임 시에 화면을 구성 또는 변경하는 방법의 핵심이 바로 프래그먼트 트랜잭션이다. 
프래그먼트 트랜잭션은 프래그먼트 리스트에 프래그먼트를 추가(add), 삭제(remove), 첨부(attach), 분리(detach), 변경(replace)하는 데 사용된다.
프래그먼트 트랜잭션을 사용하면 여러 개의 오퍼레이션(트랜잭션으로 실행되는 각 함수 코드)을 묶어서 수행할 수 있다.
> 예_다수의 프래그먼트를 동시에 서로 다른 컨테이너에 추가하는 경우

<img src="https://user-images.githubusercontent.com/84364741/243623836-4105495c-7472-47c9-9be4-76f61b0c7703.png" width="50%">

FragmentManager는 프래그먼트 트랜잭션의 백 스택을 유지 괸라한다. 따라서 프래그먼트 트랜잭션이 다수의 오퍼레이션을 포함한다면 해당 트랜잭션이 백 스택에서 제거될 때 이 오퍼레이션들이 역으로 실행된다.
그러므로 다수의 프래그먼트 오퍼레이션들을 하나의 트랜잭션으로 묶으면 UI 상태를 더욱 잘 제어할 수 있다.

FragmentManager.beginTransaction() 함수는 FragmentTransaction의 인스턴스를 생성해 반환한다.
> FragmentTransaction 클래스는 **플루언트 인터페이스(fluent interface)**를 사용한다.
> 플루언트 인터페이스는 코드를 이해하기 쉽게 해주는 객체지향 기법이며, 일반적으로 함수의 연쇄 호출 형태로 구현된다.

FragmentTransaction을 구성하는 함수들은 Unit이 아닌 FragemntTransaction 객체를 반환하기 때문에 연쇄 호출이 가능하다.


## Fragment 상태 관리
여러가지 이유로 액티비티가 소멸되었다가 다시 생성될 때를 대비해서 Fragment들은 리스트에 보존되어 있는다.
그렇기 때문에 액티비티가 재생성 되어도 FragmentManager 인스턴스가 그 리스트를 가져와 Fragment가 기존에 있었다면 리스트에서 해당 Fragment를 가져올 수 있게 된다. (없다면 생성해주고 FragmentManager에 등록 해주면 된다)


## FragmentManager와 Fragment의 생명주기
프래그먼트의 생명주기는 액티비티와 유사하다(생명주기 콜백함수는 더 세분화 되있음)
프래그먼트 생명주기 상태는 중단(Stopped), 일시 중지(Paused), 실행 재개(Resumed)가 있고, 이러한 상태가 전환될 때 필요한 일을 처리하는 콜백 함수들이 있다. (이러한 함수들은 액티비티 생명주기 함수들과 대응됨)

+ 프래그먼트는 액티비티를 대신해 작동하므로 프래그먼트의 상태는 액티비티의 상태를 반영해야 한다. 따라서 프래그먼트는 액티비티의 작업을 처리하기 위해 액티비티와 일치하는 생명주기 함수가 필요하다.

<img src="https://user-images.githubusercontent.com/84364741/243624271-00d460aa-7a0f-47c5-a80b-bf17797ac20f.png" width="70%">

### 프래그먼트 생명주기와 액티비티 생명주기의 다른점
프래그먼트 생명주기 함수는 안드로이드 운영체제가 아닌 호스팅 액티비티의 FragmentManager가 호출한다는 점이다. 
그렇기 때문에 프래그먼트는 액티비티가 내부적으로 처리해서 안드로이드 운영체제는 액티비티가 사용하는 프래그먼트에 관해서는 아무것도 모른다.
> 프래그먼트의 콜백함수인 onAttach, onCreate, onCreateView, onViewCreated 함수들은 프래그먼트를 FragmentManager에 추가할 때 호출된다.

onActivityCreated 함수는 호스팅 액티비티의 onCreate 함수가 실행 된 후 호출된다.
> 앱에서는 호스팅 액티비티의 onCreate에서 프래그먼트를 추가하면, onActivityCreated 함수는 프래그먼트가 추가된 후에 호출된다.

Q. 액티비티가 이미 실행 중일 때 프래그먼트를 추가하면 어떻게 될까?
A. 이때 FragmentManager는 해당 프래그먼트가 호스팅 액티비티의 상태를 따라잡는 데 필요한 프래그먼트 생명주기 함수를 몇 개이든지 간에 차례대로 즉시 호출한다.
> 예를들어 실행 중인 액티비티에 프래그먼트가 추가되면 onAttach() - onCreate() - onCreateView - onActivityCreated() - onStart() - onResume()의 순서로 이함수들을 연속으로 호출한다.

프래그먼트의 상태가 액티비티의 상태를 따라잡으면 이후부터는 호스팅 액티비티의 FragmentManager가 액티비티 상태와 동조된 프래그먼트 상태를 유지한다.
즉, 안드로이드 운영체제로부터 액티비티 생명주기 함수들이 호출되면 이것과 부합되는 프래그먼트 생명주기 함수들을 호출한다.


## 프래그먼트를 사용하는 애플리케이션 아키텍처
프래그먼트는 주요 컴포넌트를 재사용하게끔 캡슐화한다. (컴포넌트는 전체 화면을 나타낸다)
> 만일 한 번에 많은 프래그먼트를 화면에 넣으면 프래그먼트 트랜잭션 때문에 코드가 지저분하게 된다. 따라서 작은 컴포넌트들을 재사용할 때는 프래그먼트 대신 커스텀 뷰로 추출하는 것이 좋은 방법이다.

* 일반적으로 한 화면에는 최대 두 개 또는 세 개 정도의 프래그먼트를 사용하는 것이 좋다.(적을수록 좋다)


## 프래그먼트 사용 여부 결정하기
프래그먼트는 안드로이드 커뮤니티에서 논의가 많은 주제다.
> 어떤 사람들은 프래그먼트와 생명주기에 관련해 추가되는 복잡성이 부정적이라 프래그먼트를 절대 사용하지 않는다.
> 허나 이러한 생각은 문제가 있다. ViewPager나 Jetpack 내비게이션 라이브러리 같이 프래그먼트에 의존하는 안드로이드 API가 존재하기 때문이다.
> 또, 프래그먼트 의존 API가 없더라도 프래그먼트는 많은 요구사항을 갖는 큰 애플리케이션에 유용하다. (반면, 단일 화면을 갖는 애플리케이션에는 프래그먼트가 필요하지 않다.)

UI 프래그먼트를 호스팅하는 액티비티로 기존 액티비티를 변경하는 것은 어렵지 않지만 성가신 일이 여럿 생길 수 있다.
> 액티비티로 관리되는 UI와 프래그먼트로 관리되는 UI가 뒤섞여 혼란만 가중되기 때문이다.
> 그럴 바에는 아예 처음부터 프래그먼트를 사용해서 코드를 작성하는 것이 훨씬 더 쉽고 재작업에 따르는 고통을 걱정하지 않아도 된다.
